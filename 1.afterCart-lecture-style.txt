
======================================================    <강의에서 한 cart>   ======================================================

-   * KEY POINT 
        : 세션에 모델(사용자함수)을 담기

1. [ session 안에 카트에 담을 항목을 저장] **************
2. [ 미들웨어에 session 을 사용한 cart 안에 값 유무를 판단..?]

    1. cart model 추가 ***************************************

        class Cart{
            constructor(items = [], totalQuantity, totalPrice){        ==>> 그냥Cart()쓰면 초기화가 될 용로도 [기본값을 빈 Array로 만듬]
                this.items = itmes;
                this.totalQuantity = totalQuantity;
                this.totalPrice = totalPrice;
            }
        }

        //집어넣을함수
        addItem(product){                   ==>> 파라미터는 product
            const cartItem ={               ==>> 함수를 실행하면 cartItem 이라는 항목이 만들어지고
                product:product,                 session에 넘길 값을 저장할것이다.
                quantity:1,
                totalPrice: product.price
            }

            //중복확인코드
            for(i=0; i< this.items.length; i++ ){                       ==>> 카트에 들어간 모든 항목에 대하여,
                const item = this.items[i]  
                //중복항목에대하여                           
                if(item.product.id === product.id){                      ==>> 이미저장된 아이디[item.product.id]와, 파라미터에 의해 새로입력된 아이디[product.id] 같다면
                    cartItem.quantity = cartItem.quantity + 1;                                 ==>> 카트아이템의 quantity가 +1 된다.
                    cartItem.totalPrice = cartItem.totalPrice + product.price;
                    this.items[i] = cartItem;                               ==>> 중복된 항목을 재정리해서 업데이트하는느낌
                    this.totalQuantity++
                    this.totalPrice += product.price;
                    return                                                  ==>> 추가된거면, 이미 있던걸 또 추가하면 안되니까, return 해서 다음걸 막음
                }
            }
            //중복되지않으면새항목투입
            this.items.push(cartItem)
            this.totalQuantity++
            this.totalPrice += product.price
        } 

        ==>> 모든 넣은 아이템을 빼서, 확인 => [새로 집어넣을 "product와" "constructor" 안을 비교하여]같은 아이디가 있다면, 
                                                                            "cartItem" 이라는 객체의 '수량' 값을 증가시키고 retrun한다.
                그러니까 만약, product id와 constructor안("이미 넣어진 item")의 값이 다르다면
                [새로운 cartItem을 , constructor 안에 넣는다]


    2. middleware에 추가 *******************************************************

        const Cart = require("카트모델위치")

        function initializeCart(req,res,next){

            if(!req.session.cart){                          ==>> 카트세션에 값이 없다면, 카트는 빈카트
                cart = new Cart()
            } else{                                         ==>> 카트세션에 값이 있다면, 카트는 세션에 저장된 값을 넣어줌
-               cart = new Cart(req.session.cart.items)
            }
-           res.locals.cart = cart;                         ==>> [세션 자체에, 카트 모델을 담아!!, res.locals 처리!!]

            next()
        }

    -   ==>>  [세션 자체에!!!! 카트 모델을 담아!!!!], 
                "카트"라는 모델의 "constructor" 안에 "값을 전부 담아" [세션을 만든 후], "locals 처리한다."

            [여기저기 돌아다니면서 사용가능한 모델이 완성되었다!]


    3. middleware 활성화 [세션다음에]


    4. CONSTROLLER 사용

        const Product = require("product모델")

        function addCartItem(req,res){
            let product;
            product = [db에서 product의 정보를 가져와 (productid로) ]

            res.locals.cart.addItem(product)            ==>> locals 처리된 카트(사용자함수)에서 함수를 실행 ==> Cart의 constructor 안에 item 이 담기고, [그것은 곧 전역에 쓰일 수있음]
            req.session.cart = res.locals.cart          ==>> 저장 함수를 사용후, 혹시모르니, 세션에 다시넣음

            res.status(201).json({
                message : "..."
                newTotalItems: res.locals.cart.totalQuantity;   ==>>  res.locals.cart 안에 totalQuantity 를 만들어 넘김(model의 Cart에 this.totalQuantity 로 들어갈것)
            })                                                  ==>>  res.locals 함수는 이미 session처럼 전역을 이동하므로, 사용가능한 행동
        }

