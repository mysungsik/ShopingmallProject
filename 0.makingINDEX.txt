1. 키페이지 모델링
2. 작업 순서 정하기 (접근방법)
3. NODE작업
4. ejs 설치, view engine set

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
6. 제대로된 views 만들기 : signup 부터

0. 새로운 형태의 코딩
    1. this의 활용
    2. req.body.[dash-dash]

================================================================================================================================================================
1. 키페이지 모델링
    <VIEW>
        [관리자] 
            1. 관리자용 메인 페이지
            2. 쇼핑몰에 제공되는 모든 물품
            3. 물품 등록
            4. 물품 업데이트
            5. 모든 고객이 주문한 모든 주문을 확인

        [고객]  
            1. 쇼핑물에 제공되는 모든 물품 확인
            2. 물품의 상세정보
            3. 카트에 담기
            4. 주문확인 페이지

        [공통]      
            1. 회원가입
            2. 로그인
            3. 로그아웃

    <MODEL> 에 저장 할 것 미리 설계

        [USER]
            : 이메일, 패스워드, 이름, 주소, 전화번호, 관리자여부

        [PRODUCT]
            : 물품이름, 물품짧은 설명, 가격, 이미지, 자세한 설명, 총 평점
        
        [CART]
            : 물품 총 가격, 물품 갯수

        [ORDER]
            :  USER / PRODUCT 데이터들, CART 데이터, 시간, 상태

        [COMMENT]
            : 평점, 후기, 올린시간


2. 작업 순서 정하기 (접근방법)

    1) VIEW, CSS 로 시작해서, 페이지를 하나씩 구축하는 방법

    2) [인증, 글 로 나누어], "인증"[에 관련된 페이지와 모델, 컨트롤러 작업 후], "글"[에 관한 페이지와 모델, 컨틀롤러를 작업하는 방법]
    
    3) 기타 등

    ==>> 2번선택
        

3. NODE작업
    1) 서버 구축 (app.js)
    2) db연결   (database/database.js)

        * 
        * 패키지설치   :npm init, express, mongodb, nodemon

4. ejs 설치, view engine set

- [ VIEW의 BASE 작업]

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
    : get해서 render정도
        
    [연결해두고, 렌더대충 걸어두고, 작업시작]

    [내가 나눈 라우트]

    client 사이드 + 기본기능
        : 쇼핑몰을 이용하는 고객이 들어갈 라우트들 모을것

    admin 사이드
        : 쇼핑몰 운영할 운영자가 들어갈 라우트 모을것


6. 제대로된 views 만들기 : signup 부터

    간단한 <header 작업> + <public> [css]작업 + <app.js> 에서 public을 static으로 배포 
    <views> - <auth> - [signup] 부터 시작

-   * render 할때, views에 있는 경로 잘 지정하기 [ <app.js> 에서  views 폴더 까지만 지정했기 때문에, 그 이후는 render의 주소로 할것임]
        function getSignup(req,res){
            res.render("customer/auth/signup")
        }

7. 제대로된 CSS 기본 만들기
    : BASE 의 기본CSS설정들 (--bakcground-color : ...  같은것들) 설정
    : 기본으로 깔릴 header와  body, html의 설정

-   : 하나하나마다 MAIN DIV들은, 기본 넓이와 함께, max-width를 꼭 지정해둘것.


================ [ CONTROLLER의 BASE 작업] + [model 작업] + [ csrf 패키지 추가] ====================

8. signup의 post로, 데이터베이스에 값을 집어넣게하기

    : 값 받아와야하니, urlendcoded 추가
    : model 작업을 통해, 데이터베이스에 넣는 작업 

9. signup의 validation ( confirm 값이 다르다던가, 아이디가 이미 있다던가... 등등) 추가

10. model에 insertOne 추가

11. 세션추가 + csrf 패키지 추가 + middleware 폴더 안으로 리팩토링
    npm install express-session,  connect-mongodb-session
    npm install csurf

-  csrf 토큰에는 session 이 필요해!!!!

12. signup에 session 추가 + 플래싱 +  util 폴더로 리팩토링
    : 로그인 양식 잘못썻을때, 새로고침되지않게

13. login 에 auth session 추가


[여기까지 놓친부분1]
1) <app.js> 의 connectToDatabase의 catch.error
2) views 폴더의 세분화
3) 세분화된 views 폴더에, controller에서 render할때의 주소
4) ejs템플릿에서, heade include할때, 값 넘겨서 title 값 바꾸기

5) model에서, 객체 안에 값을 담을때, 객체안의 객체를 사용 
        {address = { street : street, 
                    postal : postal ...}}

6) csurf의 사용중 [세션이 반드시 필요하다는!]

7) 전체 에러 핸들링 middleware
        function(error,req,res,next){ ... }

================================[다시 VIEW 작업 이번엔 LOGIN]================================

13. login views 작업

================================[ 다시 controllers 작업 LOGIN ]================================

14. login contollers 작업, + session 
    :

15. login 의 model  작업 [findOne]

16. 로그인 성공시 [ AUTH 부여하기 (ID로)], 
    id db에서 빼와서 저장할때, toString() 써서 저장
        * db로 보내서 찾을때는 ObjectId 썻던거 기억해

17. [부여한 AUTH를, 미들웨어 사용하여 템플릿에 보내서 동적헤더만들기]

[여기까지 놓친부분2]

1)login의 model파트, 자동으로 반환되는 프로미스
2)세션을 만들기만하고, save한 후!!! 렌더되게 혹은  redirect 되게 만들어야하는데
        그냥 만들고 바로  redirect 해버림
        ==>> 너무 빠르게 지나가서 세션이 미처 저장되지 않았는데 페이지가 넘어갈 가능성 충분
    
3)auth하기 위해 저장하는 user session에, 더이상 이메일, name 등을 넣지말고
        아이디가 저장되어 있는  데이터베이스의 _id 값으로 저장할 것.
        , [찾을때는  ObjectId() 를 사용하고(특수한 형태의 값이므로)]
        , [빼올때는 _id.toString()으로 값을 저장하는 습관이 좋다]
            ==>> toString 이유 궁금!

18. 로그아웃 구현하기

19. 비동기 작업의 오류처리 [ TRY{}, CATCH(ERROR){}]
    비동기작업이 실패할 경우 [자동적으로 되는 오류처리 render500 이 안먹힌다.]

-   try, catch 를 통해 오류처리한다.
        * 오류처리시 try의 스코프 안으로, 변수가 들어가서 밖으로 못나오는 경우가 있다.
            그럴때는, 변수를 바깥으로 빼서 정의해주고, 스코프 안에서는 변경만 하도록 한다.

        ex) let test
            try{
                test = ...
            }
            catch(error){
                next(error)
                return
            }
-   기준 : 데이터베이스에서 불러오고, 집어넣는 행위를 하는 비동기작업은 필수!

20. 로그인, 회원가입 마무리
    : 잡다코드 정리, 리팩토링, validation, userinputsession, 다듬기 등 ....

21. [관리자 권한 부여하여, 관리자 페이지 만들기] - 일단은 데이터베이스에서 수동으로 admin : ture 추가
    : admin 추가하고, auth 전용 session에 req.session.admin 해서 추가

22. admin 페이지에서, manage product [VIEW 작업]
    : 일단, 페이지에 admin 이 아니면, 못들어가게
    : 물건 추가, 물건 상세 페이지 업데이트, 등

23. manage product [route, controllers 작업]
    : 물건 정보 db에 넣어서 list 로 뽑기,
    
-   : Ajax 요청으로, update 만들어보기 // [실패!! id값 빼오는것부터 잘못됌 강의한번볼것]


24. 다시돌아가 헤더 [모바일 버젼 만들기]




================================================================================================================================================================

0. 새로운 형태의 코딩
    1. this의 활용

        [생성자 함수 내의 함수에서] [this를 사용하면, 생성자함수 내의 함수를, 받아쓸 수 있다.]
        class Fun {
            constructor{
                ...
            }

            fun1(){
                ...
            }
            fun2(){
                const thisTest = this.fun1()        ==>>  fun1의 결과값을, 받아 쓸 수 있다.
            }
        }

    2. req.body.[dash-dash]
        
        : HTML의 name 안에 '-' 가 들어간다면, req.body[dash-dash]
            "대괄호를 사용하자"

