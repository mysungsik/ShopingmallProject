1. 키페이지 모델링
2. 작업 순서 정하기 (접근방법)
3. NODE작업
4. ejs 설치, view engine set

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
6. 제대로된 views 만들기 : signup 부터



[새로운 형태의 코딩]
    1. this의 활용
    2. req.body.[dash-dash]

================================================================================================================================================================
1. 키페이지 모델링
    <VIEW>
        [관리자] 
            1. 관리자용 메인 페이지
            2. 쇼핑몰에 제공되는 모든 물품
            3. 물품 등록
            4. 물품 업데이트
            5. 모든 고객이 주문한 모든 주문을 확인

        [고객]  
            1. 쇼핑물에 제공되는 모든 물품 확인
            2. 물품의 상세정보
            3. 카트에 담기
            4. 주문확인 페이지

        [공통]      
            1. 회원가입
            2. 로그인
            3. 로그아웃

    <MODEL> 에 저장 할 것 미리 설계

        [USER]
            : 이메일, 패스워드, 이름, 주소, 전화번호, 관리자여부

        [PRODUCT]
            : 물품이름, 물품짧은 설명, 가격, 이미지, 자세한 설명, 총 평점
        
        [CART]
            : 물품 총 가격, 물품 갯수

        [ORDER]
            :  USER / PRODUCT 데이터들, CART 데이터, 시간, 상태

        [COMMENT]
            : 평점, 후기, 올린시간


2. 작업 순서 정하기 (접근방법)

    1) VIEW, CSS 로 시작해서, 페이지를 하나씩 구축하는 방법

    2) [인증, 글 로 나누어], "인증"[에 관련된 페이지와 모델, 컨트롤러 작업 후], "글"[에 관한 페이지와 모델, 컨틀롤러를 작업하는 방법]
    
    3) 기타 등

    ==>> 2번선택
        

3. NODE작업
    1) 서버 구축 (app.js)
    2) db연결   (database/database.js)

        * 
        * 패키지설치   :npm init, express, mongodb, nodemon

4. ejs 설치, view engine set

- [ VIEW의 BASE 작업]

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
    : get해서 render정도
        
    [연결해두고, 렌더대충 걸어두고, 작업시작]

    [내가 나눈 라우트]

    client 사이드 + 기본기능
        : 쇼핑몰을 이용하는 고객이 들어갈 라우트들 모을것

    admin 사이드
        : 쇼핑몰 운영할 운영자가 들어갈 라우트 모을것


6. 제대로된 views 만들기 : signup 부터

    간단한 <header 작업> + <public> [css]작업 + <app.js> 에서 public을 static으로 배포 
    <views> - <auth> - [signup] 부터 시작

-   * render 할때, views에 있는 경로 잘 지정하기 [ <app.js> 에서  views 폴더 까지만 지정했기 때문에, 그 이후는 render의 주소로 할것임]
        function getSignup(req,res){
            res.render("customer/auth/signup")
        }

7. 제대로된 CSS 기본 만들기
    : BASE 의 기본CSS설정들 (--bakcground-color : ...  같은것들) 설정
    : 기본으로 깔릴 header와  body, html의 설정

-   : 하나하나마다 MAIN DIV들은, 기본 넓이와 함께, max-width를 꼭 지정해둘것.


================ [ CONTROLLER의 BASE 작업] + [model 작업] + [ csrf 패키지 추가] ====================

8. signup의 post로, 데이터베이스에 값을 집어넣게하기

    : 값 받아와야하니, urlendcoded 추가
    : model 작업을 통해, 데이터베이스에 넣는 작업 

9. signup의 validation ( confirm 값이 다르다던가, 아이디가 이미 있다던가... 등등) 추가

10. model에 insertOne 추가

11. 세션추가 + csrf 패키지 추가 + middleware 폴더 안으로 리팩토링
    npm install express-session,  connect-mongodb-session
    npm install csurf

-  csrf 토큰에는 session 이 필요해!!!!

12. signup에 session 추가 + 플래싱 +  util 폴더로 리팩토링
    : 로그인 양식 잘못썻을때, 새로고침되지않게

13. login 에 auth session 추가


[여기까지 놓친부분1]
1) <app.js> 의 connectToDatabase의 catch.error
2) views 폴더의 세분화
3) 세분화된 views 폴더에, controller에서 render할때의 주소
4) ejs템플릿에서, heade include할때, 값 넘겨서 title 값 바꾸기

5) model에서, 객체 안에 값을 담을때, 객체안의 객체를 사용 
        {address = { street : street, 
                    postal : postal ...}}

6) csurf의 사용중 [세션이 반드시 필요하다는!]

7) 전체 에러 핸들링 middleware
        function(error,req,res,next){ ... }

================================[다시 VIEW 작업 이번엔 LOGIN]================================

13. login views 작업

================================[ 다시 controllers 작업 LOGIN ]================================

14. login contollers 작업, + session 
    :

15. login 의 model  작업 [findOne]

16. 로그인 성공시 [ AUTH 부여하기 (ID로)], 
    id db에서 빼와서 저장할때, toString() 써서 저장
        * db로 보내서 찾을때는 ObjectId 썻던거 기억해

17. [부여한 AUTH를, 미들웨어 사용하여 템플릿에 보내서 동적헤더만들기]

[여기까지 놓친부분2]

1)login의 model파트, 자동으로 반환되는 프로미스
2)세션을 만들기만하고, save한 후!!! 렌더되게 혹은  redirect 되게 만들어야하는데
        그냥 만들고 바로  redirect 해버림
        ==>> 너무 빠르게 지나가서 세션이 미처 저장되지 않았는데 페이지가 넘어갈 가능성 충분
    
3)auth하기 위해 저장하는 user session에, 더이상 이메일, name 등을 넣지말고
        아이디가 저장되어 있는  데이터베이스의 _id 값으로 저장할 것.
        , [찾을때는  ObjectId() 를 사용하고(특수한 형태의 값이므로)]
        , [빼올때는 _id.toString()으로 값을 저장하는 습관이 좋다]
            ==>> toString 이유 궁금!

18. 로그아웃 구현하기

19. 비동기 작업의 오류처리 [ TRY{}, CATCH(ERROR){}]
    비동기작업이 실패할 경우 [자동적으로 되는 오류처리 render500 이 안먹힌다.]

-   try, catch 를 통해 오류처리한다.
        * 오류처리시 try의 스코프 안으로, 변수가 들어가서 밖으로 못나오는 경우가 있다.
            그럴때는, 변수를 바깥으로 빼서 정의해주고, 스코프 안에서는 변경만 하도록 한다.

        ex) let test
            try{
                test = ...
            }
            catch(error){
                next(error)
                return
            }
-   기준 : 데이터베이스에서 불러오고, 집어넣는 행위를 하는 비동기작업은 필수!

20. 로그인, 회원가입 마무리
    : 잡다코드 정리, 리팩토링, validation, userinputsession, 다듬기 등 ....

21. [관리자 권한 부여하여, 관리자 페이지 만들기] - 일단은 데이터베이스에서 수동으로 admin : ture 추가
    : admin 추가하고, auth 전용 session에 req.session.admin 해서 추가

22. admin 페이지에서, manage product [VIEW 작업]
    : 일단, 페이지에 admin 이 아니면, 못들어가게
    : 물건 추가, 물건 상세 페이지 업데이트, 등

-   : step, 등의 view 논리

23. manage product [route, controllers 작업]
    : 물건 정보 db에 넣어서 list 로 뽑기,
    
-   : Ajax 요청으로, update 만들어보기 // [실패!! id값 빼오는것부터 잘못됌 강의한번볼것]


24. 다시돌아가 헤더 [모바일 버젼 만들기]

    : 웹버젼을 복사해서, 하나 더 만들어서 , include해서, <aside> 에 모바일쪽에 붙여서, 모바일은 따로 스타일링
    < 사용 >  미디어쿼리, 쿼리선택자( ?=...) , 자바스크립트리스너, !important
    
    < 오류 >
    - includes 폴더 안에 들어있는 두개의 파일을 include 할때,  [ include(includes/파일명) ]이 아니라, 이미 같은 폴더에 있으니 [incldue(파일명)] 이 맞다.
    - 왜 미디어쿼리를 하면, 내 햄버거 버튼의 flex가 무너지지? (max-width로 함)
        ==>> 왜그러진 모르겠지만, [햄버거버튼은] min-width를 사용하여, [원래는 있었다가, min-width 보다 커지는 순간, 나타나게 ]
            [min-width 모바일 우선]  [max-width 데스크탑우선] ==>> [모바일 우선 승!]

25. manage product 수정
    < 수정>
    1. 모바일 형태일 경우, manage product의 수정이 너무나 어려워진다. 젠장 다시 바꾸자, 다른페이지로 가게

26. manage product 보충 [  file 탐색기!! , ajax 요청으로 섬네일추가하기]
    :  npm install --save multer, uuid

-   다시해보는 파일탐색기 기능!! 중요중요!

-   뻐킹... [파일 업로드만 하려고 하면, csrf 토큰이 안먹던 이유!!]
    => form 에,  enctype 이 들어가서, hidden value가 안먹으니까!!!
    ==>> csurf의 csrf 토큰 확인하기 플랜 B [?_csrf = <%= locals.csrfToken %>]
        : form action ="...?_csrf=<%= locals.csrfToken %>"

-   파일을 서버에서 받을때는  req.files! 에스가 붙어있다!


    1.  <view>  form => enctype="multipart/form-data"
                input type = "file" , accept = "image/* "

    2. <middleware> multer 패키지 설치

                    cosnt upload = multer({storage})

                    const storage = multer.diskStorage({
                        ...
                    })

-                   ==>> fileupload middleware 에 잘 정리해두었음. 필독

    
    3. <node>   파일데이터 받아서 데이터베이스에 저장
                    
                model 에 constructor 에는 나중에 사용할 [req.body들의 것들 뿐 아니라]
                                                       [ this.image = ]
                    저장할때, req.body들 뿐 아니라
                * 파일 이미지는 [이미지에 따로 하는것이지 req.body 들이랑 같이 묶이는것 아님]


    ==> 미들웨어로 가는 이유
        : 파일업로드라는 행위를 할때, 미들웨어를 거쳐( upload.single("HTML의 name") ) 파일을 저장하기 때문에

27. [MODEL 작업 시작] : 파일 업로드와 더불어 받은, req.body 들 까지 전부 데이터베이스에 넣을 


-    쓸데없이 보낸 나의 시간에 대하여....
        model에 있는 사용자함수 Product에 = req.body.name , req.body....으로 넣으려고 
            일부로 파라미터에 productData 라 쓰고 .HTML의name 을 적었는데
            그걸 잘못적어서 undefine 이 나오는걸 개짓했네...

    
-   근데 왜  사용자함수에 image에 값이 안들어갈까..?
        결국 따로 빼서 넣었음

================================================================================================================================================================

[새로운 형태의 코딩 - 새로 안 것]

1. this의 활용

    [생성자 함수 내의 함수에서] [this를 사용하면, 생성자함수 내의 함수를, 받아쓸 수 있다.]
    class Fun {
        constructor{
                ...
        }

        fun1(){
                ...
        }
        fun2(){
            const thisTest = this.fun1()        ==>>  fun1의 결과값을, 받아 쓸 수 있다.
        }
    }

2. req.body.[dash-dash]
        
    : HTML의 name 안에 '-' 가 들어간다면, req.body[dash-dash]
        "대괄호를 사용하자"

3. CSS [ classList , togle()]

    :  classList 는, 클래스를 관리하는 코드, .add(),  .remove(),  ... togle() 이 있다.

-   : toggle()
        ==>> [classList에 있다면, 제거하고, 없다면 생성하는] [토클의 기능]
        ==>> [새 페이지가 렌더되면, 당연하게도 사라지니까, 편함] [HTML 자체가 변경되는 것이 아니니까]

4. CSS [ calc(100vh - 5rem); ]

    : clac [ 계산해서 작동한다.]
-   : 100vh [ 100%의 최대높이를 말한다.]

5. csrf 토큰과 파일업로드를 같이 사용할때는 쿼리로 csrfToken을 제시해야한다.

    <form action="/admin/products?_csrf=<%= locals.csrfToken %>" method="POST" enctype="multipart/form-data" >                                  "

6. 사용자 함수 사용시, 파라미터에, req.body를 대신할 것을 넣어두고, 사용할때 ...req.body를 사용할 수 있다.

    <model>
        class Product {
            constructor(productData){
                this.name = productData.productName;
                this.price = productData.productPrice;
                ...

    <node>
        const data = new Product({
            ...req.body,
        })

-   왠지 안돼서, 그냥 따로 쓰는 방법으로 바꿨다.


7. 파일선택기는 req.file로 접근할 수 있고,  req.file을  console.log 해서 나온 값들또한 req.file.값 으로 접근할 수 있다.

    console.log(req.file)

    xx = req.file.filename
    yy = req.file.path
    ...

8. 파일 업로드를 위해, multer 를 사용할때, 원리를 잘 기억하자
    
    미들웨어 처리할것은 upload
    upload 안에 들어갈 것은 multer({storage})
    storage 안에 들어갈 것은 multer.diskStorage{destination, filename} 이다.

9. 항상, 오류처리를 염두해두자.
