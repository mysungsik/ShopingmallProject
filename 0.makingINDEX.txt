1. 키페이지 모델링
2. 작업 순서 정하기 (접근방법)
3. NODE작업
4. ejs 설치, view engine set

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
6. 제대로된 views 만들기 : signup 부터


[주의사항(맨날실수하는)]


[새로운 형태의 코딩]
    1. this의 활용
    2. req.body.[dash-dash]

================================================================================================================================================================
1. 키페이지 모델링
    <VIEW>
        [관리자] 
            1. 관리자용 메인 페이지
            2. 쇼핑몰에 제공되는 모든 물품
            3. 물품 등록
            4. 물품 업데이트
            5. 모든 고객이 주문한 모든 주문을 확인

        [고객]  
            1. 쇼핑물에 제공되는 모든 물품 확인
            2. 물품의 상세정보
            3. 카트에 담기
            4. 주문확인 페이지

        [공통]      
            1. 회원가입
            2. 로그인
            3. 로그아웃

    <MODEL> 에 저장 할 것 미리 설계

        [USER]
            : 이메일, 패스워드, 이름, 주소, 전화번호, 관리자여부

        [PRODUCT]
            : 물품이름, 물품짧은 설명, 가격, 이미지, 자세한 설명, 총 평점
        
        [CART]
            : 물품 총 가격, 물품 갯수

        [ORDER]
            :  USER / PRODUCT 데이터들, CART 데이터, 시간, 상태

        [COMMENT]
            : 평점, 후기, 올린시간


2. 작업 순서 정하기 (접근방법)

    1) VIEW, CSS 로 시작해서, 페이지를 하나씩 구축하는 방법

    2) [인증, 글 로 나누어], "인증"[에 관련된 페이지와 모델, 컨트롤러 작업 후], "글"[에 관한 페이지와 모델, 컨틀롤러를 작업하는 방법]
    
    3) 기타 등

    ==>> 2번선택
        

3. NODE작업
    1) 서버 구축 (app.js)
    2) db연결   (database/database.js)

        * 
        * 패키지설치   :npm init, express, mongodb, nodemon

4. ejs 설치, view engine set

- [ VIEW의 BASE 작업]

5. 인증영역 [대충] <views>, <routes> 대충 작업 [controller에 넣어가면서 작업]
    : get해서 render정도
        
    [연결해두고, 렌더대충 걸어두고, 작업시작]

    [내가 나눈 라우트]

    client 사이드 + 기본기능
        : 쇼핑몰을 이용하는 고객이 들어갈 라우트들 모을것

    admin 사이드
        : 쇼핑몰 운영할 운영자가 들어갈 라우트 모을것


6. 제대로된 views 만들기 : signup 부터

    간단한 <header 작업> + <public> [css]작업 + <app.js> 에서 public을 static으로 배포 
    <views> - <auth> - [signup] 부터 시작

-   * render 할때, views에 있는 경로 잘 지정하기 [ <app.js> 에서  views 폴더 까지만 지정했기 때문에, 그 이후는 render의 주소로 할것임]
        function getSignup(req,res){
            res.render("customer/auth/signup")
        }

7. 제대로된 CSS 기본 만들기
    : BASE 의 기본CSS설정들 (--bakcground-color : ...  같은것들) 설정
    : 기본으로 깔릴 header와  body, html의 설정

-   : 하나하나마다 MAIN DIV들은, 기본 넓이와 함께, max-width를 꼭 지정해둘것.


================ [ CONTROLLER의 BASE 작업] + [model 작업] + [ csrf 패키지 추가] ====================

8. signup의 post로, 데이터베이스에 값을 집어넣게하기

    : 값 받아와야하니, urlendcoded 추가
    : model 작업을 통해, 데이터베이스에 넣는 작업 

9. signup의 validation ( confirm 값이 다르다던가, 아이디가 이미 있다던가... 등등) 추가

10. model에 insertOne 추가

11. 세션추가 + csrf 패키지 추가 + middleware 폴더 안으로 리팩토링
    npm install express-session,  connect-mongodb-session
    npm install csurf

-  csrf 토큰에는 session 이 필요해!!!!

12. signup에 session 추가 + 플래싱 +  util 폴더로 리팩토링
    : 로그인 양식 잘못썻을때, 새로고침되지않게

13. login 에 auth session 추가


[여기까지 놓친부분1]
1) <app.js> 의 connectToDatabase의 catch.error
2) views 폴더의 세분화
3) 세분화된 views 폴더에, controller에서 render할때의 주소
4) ejs템플릿에서, heade include할때, 값 넘겨서 title 값 바꾸기

5) model에서, 객체 안에 값을 담을때, 객체안의 객체를 사용 
        {address = { street : street, 
                    postal : postal ...}}

6) csurf의 사용중 [세션이 반드시 필요하다는!]

7) 전체 에러 핸들링 middleware
        function(error,req,res,next){ ... }

================================[다시 VIEW 작업 이번엔 LOGIN]================================

13. login views 작업

================================[ 다시 controllers 작업 LOGIN ]================================

14. login contollers 작업, + session 
    :

15. login 의 model  작업 [findOne]

16. 로그인 성공시 [ AUTH 부여하기 (ID로)], 
    id db에서 빼와서 저장할때, toString() 써서 저장
        * db로 보내서 찾을때는 ObjectId 썻던거 기억해

17. [부여한 AUTH를, 미들웨어 사용하여 템플릿에 보내서 동적헤더만들기]

[여기까지 놓친부분2]

1)login의 model파트, 자동으로 반환되는 프로미스
2)세션을 만들기만하고, save한 후!!! 렌더되게 혹은  redirect 되게 만들어야하는데
        그냥 만들고 바로  redirect 해버림
        ==>> 너무 빠르게 지나가서 세션이 미처 저장되지 않았는데 페이지가 넘어갈 가능성 충분
    
3)auth하기 위해 저장하는 user session에, 더이상 이메일, name 등을 넣지말고
        아이디가 저장되어 있는  데이터베이스의 _id 값으로 저장할 것.
        , [찾을때는  ObjectId() 를 사용하고(특수한 형태의 값이므로)]
        , [빼올때는 _id.toString()으로 값을 저장하는 습관이 좋다]
            ==>> toString 이유 궁금!

18. 로그아웃 구현하기

19. 비동기 작업의 오류처리 [ TRY{}, CATCH(ERROR){}]
    비동기작업이 실패할 경우 [자동적으로 되는 오류처리 render500 이 안먹힌다.]

-   try, catch 를 통해 오류처리한다.
        * 오류처리시 try의 스코프 안으로, 변수가 들어가서 밖으로 못나오는 경우가 있다.
            그럴때는, 변수를 바깥으로 빼서 정의해주고, 스코프 안에서는 변경만 하도록 한다.

        ex) let test
            try{
                test = ...
            }
            catch(error){
                next(error)
                return
            }
-   기준 : 데이터베이스에서 불러오고, 집어넣는 행위를 하는 비동기작업은 필수!

20. 로그인, 회원가입 마무리
    : 잡다코드 정리, 리팩토링, validation, userinputsession, 다듬기 등 ....

21. [관리자 권한 부여하여, 관리자 페이지 만들기] - 일단은 데이터베이스에서 수동으로 admin : ture 추가
    : admin 추가하고, auth 전용 session에 req.session.admin 해서 추가

22. admin 페이지에서, manage product [VIEW 작업]
    : 일단, 페이지에 admin 이 아니면, 못들어가게
    : 물건 추가, 물건 상세 페이지 업데이트, 등

-   : step, 등의 view 논리

23. manage product [route, controllers 작업]
    : 물건 정보 db에 넣어서 list 로 뽑기,
    
-   : Ajax 요청으로, update 만들어보기 // [실패!! id값 빼오는것부터 잘못됌 강의한번볼것]


24. 다시돌아가 헤더 [모바일 버젼 만들기]

    : 웹버젼을 복사해서, 하나 더 만들어서 , include해서, <aside> 에 모바일쪽에 붙여서, 모바일은 따로 스타일링
    < 사용 >  미디어쿼리, 쿼리매서드( ?=...) , 자바스크립트리스너, !important
    
    < 오류 >
    - includes 폴더 안에 들어있는 두개의 파일을 include 할때,  [ include(includes/파일명) ]이 아니라, 이미 같은 폴더에 있으니 [incldue(파일명)] 이 맞다.
    - 왜 미디어쿼리를 하면, 내 햄버거 버튼의 flex가 무너지지? (max-width로 함)

        ==>> 왜그러진 모르겠지만, [햄버거버튼은] min-width를 사용하여, [원래는 있었다가, min-width 보다 커지는 순간, 사라지게 ]
            [min-width 모바일 우선]  [max-width 데스크탑우선] ==>> [모바일 우선 승!]

25. manage product 수정
    < 수정>
    1. 모바일 형태일 경우, manage product의 수정이 너무나 어려워진다. 젠장 다시 바꾸자, 다른페이지로 가게

26. manage product 보충 [  file 탐색기!! , ajax 요청으로 섬네일추가하기]
    :  npm install --save multer, uuid

-   다시해보는 파일탐색기 기능!! 중요중요!

-   뻐킹... [파일 업로드만 하려고 하면, csrf 토큰이 안먹던 이유!!]
    => form 에,  enctype 이 들어가서, hidden value가 안먹으니까!!!
    ==>> csurf의 csrf 토큰 확인하기 플랜 B [?_csrf = <%= locals.csrfToken %>]
        : form action ="...?_csrf=<%= locals.csrfToken %>"

-   파일을 서버에서 받을때는  req.files! 에스가 붙어있다!


    1.  <view>  form => enctype="multipart/form-data"
                input type = "file" , accept = "image/* "

    2. <middleware> multer 패키지 설치

                    cosnt upload = multer({storage})

                    const storage = multer.diskStorage({
                        ...
                    })

-                   ==>> fileupload middleware 에 잘 정리해두었음. 필독

    
    3. <node>   파일데이터 받아서 데이터베이스에 저장
                    
                model 에 constructor 에는 나중에 사용할 [req.body들의 것들 뿐 아니라]
                                                       [ this.image = ]
                    저장할때, req.body들 뿐 아니라
                * 파일 이미지는 [이미지에 따로 하는것이지 req.body 들이랑 같이 묶이는것 아님]


    ==> 미들웨어로 가는 이유
        : 파일업로드라는 행위를 할때, 미들웨어를 거쳐( upload.single("HTML의 name") ) 파일을 저장하기 때문에

27. [MODEL 작업 시작] : 파일 업로드와 더불어 받은, req.body 들 까지 전부 데이터베이스에 넣을 

    ** 특히, req.file에 들어갈, image, imagepath, imageURL 을 [더 해서] 저장해주는 것이 중요!!

    ** 추가적으로, [사용자함수 constructor]에 [db에 저장하기 위한 productId의 값으로 req.body._id 를 추가하는 것을 잊지말것!]

    ==>> 그러니까, model의 product의 constructor의 파라미터로는 [name ... warning, filename, filepath, flleURL, id] 까지!
    ==>> 그리고 [  db에서 가져온 id 저장 ]    할때    [.toString() ] 쓰는것 절대절대 잊지말것
=   추가적으로!!! id 저장에 쓸 .toString() 은, id값을 저장하지 않을때에는, 매서드 오류가 나기 때문에 if값을 넣어서 constructor 에서 작업해야한다!!!
        if(id){
            this.id = id.toString()
        }

        -    근데 fileURL은 어따쓰냐 대체 ==>> 유저들에게, 파일이 저장되어있는 폴더를 숨기고자, URL 앞에 다른 폴더주소를 넣고 STATIC을 할때 필터를 추가하여, 직접적인 폴더주소를 숨기며 제공하기위해 사용 


-    쓸데없이 보낸 나의 시간에 대하여....
        model에 있는 사용자함수 Product에 = req.body.name , req.body....으로 넣으려고 
            일부로 파라미터에 productData 라 쓰고 .HTML의name 을 적었는데
            그걸 잘못적어서 undefine 이 나오는걸 개짓했네...

    
-   근데 왜  사용자함수에 image에 값이 안들어갈까..?
        결국 req.body로 안받고, 파라미터를 전부 각각 쓴 뒤에, 값을 따로 받음


   ** Array.map() 에 관하여! [배열의 재정립]  **************************************************
-   DB에는 값을 숨겨서 넣고(전부다 넣지 말고), map을 사용해서 필요한 것은 constructor에 재정립 해서 사용하는 [아주 안전한 방법]

        ==> 하여튼 그러니까, 사용자함수객체에는, 넘길 데이터를 다 쓰더라도(객체에는 필요한 거 다 적으란 말), 
            DB에서는 숨겨야 할 것은 숨기고(DB에 폴더 위치까지 다 저장하지는 말라는 말), 그럼에도 VIEW로 넘길 것은 넘길 수 있는 방법

        Array.map( function( element ){
            return  element ...
        })

-       product-model 안에 들어있는, Array.map()
-       [DB 안에 직접적인 PATH의 저장을 피해, 사고를 미연에 방지하면서도, 재정립하여 VIEW로 값을 보내는 안전한 방법]
            * 자세한 사항은 내 블로그에 공부에 다시 정리해두었음

28. 섬네일 작업 완료

29. 값을 받아, all product 꾸미기

-   *** image 불러오는데 [미리저장한 "imageURL"을 사용해서, 불러온다.] 
        ...src="<%= product.imageURL %>  "

-   imagepath를 사용하면 되는데, 대체 왜???!?!?!?
    ==>> 사용자들의 폴더접근을 막기위한 비밀번호같은 역할로, 실제 폴더가 어딨는지 모르게 하기위한 용도

    "imageURL"을 /products/assets/uploadedImage/filename 이라고 저장했다면,

    <app.js>  에서 미들웨어를 사용해 static 으로 제공할때, 

        app.use("/products/assets", express.static("src")) 이런식으로 제공한다면, 
            
            , [미들웨어에서 접근할때] [필터를 거쳐, /products/assets 안에 있는것만 찾기때문에, ]

    <view> 에서 사용할때,
        src="<%= product.imageURL %>" 이라고 적어도,   => "/products/assets/uploadedImage/filename" 
                ==>>  "/products/assets/" 을 제끼고, 알아서 "uploadedImage/filename" 을 찾아서 간다.

    ==>> 다시말하지만, 사용하는 이유는 [사용자로부터 정확한 폴더명을 숨기기 위해서다!]

    [결론] static을 할때, app.use("검색조건", express.static("src") 를 하면
            "검색조건" 이 달려있는, "파일의 주소만",  "src 폴더에 접근해서, 파일이 있으면 공개되는 것"

30. update product, delete product 만들기
    : 파일 삭제(fs) + DB 변경 OR 삭제

31. 추가, update product 일때 [fs] 사용하여, 파일 삭제하기

32. 추가, URL 자바스크립트 내장 클래스로, 간단하게 썸네일 만들기!

32. 추가! [삭제]를 get도아니고 post도 아니고 [delete 요청을 통해!] AJAX 요청과 같은 자바스크립트기반 요청을 사용해서, 새로고침 없이 삭제하기!
   ==> [무한히 증가하는 버튼에 대하여] [어떻게 쿼리선택자로 특정 버튼을 타겟할것인가! !]

-   기본적으론 [추가연습 1번] 무한히 증식하는 버튼에 어떻게, AJAX 요청으로 특정 버튼을 타겟할것인가. 를 따르고,
-   기술적으로는,버튼의 부모요소,부모요소...부모요소, 를 타고 올라가 .remove() 하는 방법을 사용하며,

    당연하게도, 라우터에 버튼과 같은 동적주소를 입력하고, 컨트롤러에서 기능을 적어, 라우트 function에 넣는다 

    1. VIEW 버튼에 data-id = "..." 해서 동적으로 넣기 (addEventListenal로 연결할거니까 href 도 필요없다?)
    2. for문으로 리스너 달고
    3. [동적 주소]로 [ fetch로 delete 요청 보내고],
    4. 라우트에서 받아서 서버로 보내 처리한다.
        * csrf 를 잊지말자. [data-csrf] 로 보내면 좋다.

33. 서버측 validation, 에러 핸들링 추가
    : (내가 내 사이트 해킹할건 아니라 사실 필요는 크게 없지만) 있으면 좋은, 서버측 validation
        물론, 클라이언트가 사용할 공간에서는 필수이지만

    : error.code = xxx 해서 보냈던 오류처리가 있었다.
        얘가 가는곳은! 내가 미리 설정했던 오류처리 middleware!
        기본 오류처리 500 뿐 아니라    if(error.code == xxx){              를 추가하자
                                       res.status(xxx).render("...")
                                      }

34. 라우트 보호 추가 [미들웨어로 한번에 전부!!] ******************
==> [특정 authentication 이 없으면, 접근 불가 ]

        : req.path.startsWith("...") 
            ==> 만약 ...으로 시작하는 URL을 만나면 true 로 표시될것이다.

    - 위치는 auth 받은 이후, admin이 있는 것을 들어갈때 막아야 하니

        app.use(authRoute)
-       >> 이곳
        app.use(productRoute)



==================================================================================================================================
=========[ 자 이제, 고객들을 위한, 상품페이지, 카트페이지, 주문페이지로 이동한다. (주문은 로그인은 해야지!)] =========================
==================================================================================================================================

35. 고객용 전체상품페이지
==>> 적절한 URL을 적으면 , [admin용, 전체상품페이지를 render해준다음]
     if문을 사용하여, 감출건 감추고(locals.admin 조건으로), detail 버튼을 보이게 하는 것도 가능하다만(강의는 그럼)
     나는 그냥, 새 페이지 만듬

36. 디테일 페이지 만들기
    : 유저한테 보여야하니, media query 필수, transform:rotateZ(-10deg) 써보기

37. 카트에 담게하기
    : 로그인시, [ res.locals.uid = req.session.authUserId ]로, 사용자 인증 아이디(DB에서 뽑아온 _id)를 저장하는 이유가 있었따! 
    : AJAX 요청으로, 페이지 이동없이

    product-detail ajax (post) => 주문자 id와 함께, [cart db에 save] 시킴
                                주문 한다면 cart db에서 삭제하고 order db로 넘기면되고

    cart post - 주문자 id와 동일한 db들을 전부뽑아 li로 만들어서 넘김

= <현재 미구축사항>
    [order 넣는 순간, CART에 담겨진 DB 및, LI 삭제하기 => ORDER로 넘어갈거니까]     /작업완료
    [카트 안에서, 물건 제거하기] /작업완료
    [카트 컨트롤러 안에 db접근애들 MODEL로 옮기기( + ORDER model 따로 만들어야함)]


37-1. header cart에 동적 갯수 추가 (카트안에 갯수)

    방법1.  사용자 id로 된, db의 갯수를 받아와서, render하여 head로 ==>> 
            가능은 하지만 [불가] (head)는 모든 ejs에 있는 것 ==> 모든 render에 다넣어야함
    
-   방법2. middelware 혹은 session 으로 id와 같은 DB의 카트를 받아와서, 동적으로 ejs 에 넣기
    

38. 주문하게하기
    사용자 주소 받아와서, 싹 들어가게 해놓고 바뀌게도 가능하게하기




[주의사항(맨날실수하는)]==================================================================================================================================
1. [비동기식 작업에 대하여!] DB에 넣고 빼는 작업을 할때, 실수할수도 있느느데, try,catch 사용했는가?
    + try, catch 로 할때, 혹시나 변수를 내부에서만 사용가능하게 두진 않았는가?
    = 외부 변수를 let 사용하여 빼야, try 안에서만 사용가능한 지역변수화 되는것을 막을 수 있다.

2. [동기식 작업에 대하여!] if() 로, 잘 되었는지 확인 한 후에, throw() 를 하였는가?



[새로운 형태의 코딩 - 새로 안 것]==================================================================================================================================

1. this의 활용

    [생성자 함수 내의 함수에서] [this를 사용하면, 생성자함수 내의 함수를, 받아쓸 수 있다.]
    class Fun {
        constructor{
                ...
        }

        fun1(){
                ...
        }
        fun2(){
            const thisTest = this.fun1()        ==>>  fun1의 결과값을, 받아 쓸 수 있다.
        }
    }

2. req.body.[dash-dash]
        
    : HTML의 name 안에 '-' 가 들어간다면, req.body[dash-dash]
        "대괄호를 사용하자"

3. CSS [ classList , togle()]

    :  classList 는, 클래스를 관리하는 코드, .add(),  .remove(),  ... togle() 이 있다.

-   : toggle()
        ==>> [classList에 있다면, 제거하고, 없다면 생성하는] [토클의 기능]
        ==>> [새 페이지가 렌더되면, 당연하게도 사라지니까, 편함] [HTML 자체가 변경되는 것이 아니니까]

4. CSS [ calc(100vh - 5rem); ]

    : clac [ 계산해서 작동한다.]
-   : 100vh [ 100%의 최대높이를 말한다.]

5. csrf 토큰과 파일업로드를 같이 사용할때는 쿼리로 csrfToken을 제시해야한다.

    <form action="/admin/products?_csrf=<%= locals.csrfToken %>" method="POST" enctype="multipart/form-data" >                                  "

6. 사용자 함수 사용시, 파라미터에, req.body를 대신할 것을 넣어두고, 사용할때 ...req.body를 사용할 수 있다.

    <model>
        class Product {
            constructor(productData){
                this.name = productData.productName;
                this.price = productData.productPrice;
                ...

    <node>
        const data = new Product({
            ...req.body,
        })

-   왠지 안돼서, 그냥 따로 쓰는 방법으로 바꿨다.


7. 파일선택기는 req.file로 접근할 수 있고,  req.file을  console.log 해서 나온 값들또한 req.file.값 으로 접근할 수 있다.

    console.log(req.file)

    xx = req.file.filename
    yy = req.file.path
    ...

8. 파일 업로드를 위해, multer 를 사용할때, 원리를 잘 기억하자
    
    미들웨어 처리할것은 upload
    upload 안에 들어갈 것은 multer({storage})
    storage 안에 들어갈 것은 multer.diskStorage{destination, filename} 이다.

9. 항상, 오류처리를 염두해두자.


10. Array.map() 에 관하여! [배열의 재정립] ==> 하여튼 그러니까, 사용자함수객체에는 넘길 데이터를 다 쓰더라도(객체에는 필요한 거 다 적으란 말), DB에서는 숨겨야 할 것은 숨기고, 그럼에도 VIEW로 넘길 것은 넘길 수 있는 방법

    Array.map( function( element ){
    return  element ...
    })

-   product-model 안에 들어있는, Array.map()
-   [DB 안에 직접적인 PATH의 저장을 피해, 사고를 미연에 방지하면서도, 재정립하여 VIEW로 값을 보내는 안전한 방법]

11. CSRF TOKEN의 제출 원리에 관하여 + 파일 탐색기를 이용하거나, value가 따로 있을경우, csrfToken을 제출하는 방법

    csrfToken 의 제출로 
    <form> 안에 hidden value = <%= locals.csrfToken%> name="_csrf"  코드를 사용한다.

-   이 말 뜻은, FORM 안의 name과 value에 의해서 URL이 변경되어
        domain?_csrf= <%= locals.csrfToken%> 가 됌을 의미한다.
    
=   즉, 원론적으로
        form의 action 을, 
        <form action = "/...?_csrf = <%= locals.csrfToken %>">               "
-       이라고 적는다면, FORM 안의 값이 어찌됬든, 신경쓰지 않고 Form 자체의 action 으로 CSRF 토큰을 제출할 수 있게 된다.

    이것이, 파일탐색기를 쓸 때, 혹은, Form 안에 어떤 값에 의해 쿼리 매개변수로 csrf토큰을 제출하지 못하면,
    쓸 수 있는 아주 좋은 csrf토큰 제출 방법이다.


12. ERROR 를 보내는 두가지 방법
    1. const error = new Error("...")
        error.code = xxx
        throw error

    2. try{ ... }
        catch(error){
            error.code = xxx
            throw error
        }

13. CSS  transform: rotateZ(-10deg)
14. CSS  white-space: pre-wrap 
    : text, textarea 등의 텍스트에, 공백, 줄바꿈 등이 [코드에서 한대로 그대로 적용됌]

15. CSS @media (min-width: xx )를 활용해서, 센터였다가,  큰화면에서는 [text-align을 left로 두어서 편하게 볼 수 있게 만들 수 잇음]

16. 옆으로 grid
    #main-grid li{
        display: grid;
        grid-auto-flow: column;
    }

17. 자바스크립트 string에서 숫자 추출하기( char 제거) , char 추출하기(숫자제거) 
    let ms = "asdasda34534sd345345"
-   ms = ms.replace(/\D/g,"")               [ / : 조건시작 ], [\D : 숫자가 아닌것들(not Digital)], [g : 매치되는것들 전부(global))] , 들을 " " empty로
    console.log(ms)
    


    let js = "asdasda34534sd345345"
-   js = js.replace(/[^0-9]/g, "''");       [ / : 조건시작 ], [[^0-9] : 모든 숫자들], [g : 매치되는것들 전부(global))] , 들을 " " empty로
    console.log(js)


18. 배열에 추가,삭제 를 담당하는 array.splice(x,y,z) 에 관하여
    array.splice(x,y,z) 
        x: 몇번째? num
        y: 으로부터 몇개를 삭제(num)
        z: 하고 무엇을 추가?(value)

    ms = [1,2,3,4,5]

    ms.splice(1,0,4)    => 1번째로부터 아무것도 삭제하지 않고, 5를 추가
    ms.splice(3,2)      => 3번째로부터 2개를 삭제하고
    ms.splice(2,1,5)    => 2번째로부터 1개를 삭제하고, 5를 추가


19. [아무것도 없는 무한증식 Form (no action,no method)]에 addEventListener를 달아, ajax 요청을 하는 것에 관하여!
    => 브라우저의 FORM 에서는 GET, POST만 가능하니, JAVASCRIPT 로 넘겨야, PUT, PATCH 등이 가능


-   KEYPOINT : 무한증식 [FORM 태그 자체]에 addEventLinstener 를 다는것
-              [FORM 태그 자체]에  data-xxx="" 를 적어, script로 넘기는것
-              [기본 FORM의 기능을] event.preventDefault() 로 막는것
               event.target.querySelector("...") 의 사용!!!!

                ==>> 무한히 증식하는 FORM 안의 각각에 대한 태그를 타겟할 수 있음
                    FORM A의 P태그
                    FORM B의 P태그
                    ... 

    <VIEW>
        <form class= "..." data-xx="xxx"... >
            <input ...>
            <p class="pTag">  ... </p>
            <button class="btn"> update </button>
        </form>


    <JS>
        const forms = document.querySelectorAll("...")

        async function function(event){
-           event.preventDefault();
            const xx = event.target.dataset.xx
            const yy = event.target.firstElementChild.value

            data = {
                name:xx,
                age:yy
            }

            cosnt response = await fetch("...",{
                method: "PATCH",
                body : JSON.stringify(data)
                headers : {
                    "Content-Type" : "appliaction/json"
                }                     
            })

            const responseData = await response.json()

-           const formElement = event.target.querySelector(".pTag")
            formElement.textContent = "...."
        }

        for(const form of forms){
-           form.addEventListener("submit", function)
        }

                         ==>>   try,catch 추가(let response 해서 밖으로 빼는것까지)  
                                !response.ok 일경우 추가

20. JAVASCRIPT , 소수점 고정시키는 toFixed(x)
        toFixed(2) => 소수점 2째자리수 까지로 고정
        
* PATCH는 사실 POST와 똑같다.   

21. [사용자함수 안에서 db를 불러올때, 가져올 조건을 정하는 방법 ==>> { projection : {password:0, _id:0}} ]

    static async getUserInfoWithoutPassword(userid){
        const userInfo = db.getDb().collection("userInfo").findOne({_id: ObjectId(userid)},{ projection:{password:0} })
        return userInfo

   일반적으로는        findOne({_id: ObjectId(userid)},{password:0 , xx:0 ...})
   사용자함수 안에서는 [ 반드시 projection 을 통해서, 타겟해주어야 한다. ]
   

[추가연습] =============================================================================================================

1. 연습 ,댓글창의 댓글창 만들기

    ==> 댓글창의 등록버튼 => form, button으로,  ajax요청
        [등록 버튼]은 하나이기 때문에 여기서는 [form으로 btn에 data, 달아서, dataset으로 가져오면 된다.]
        [ 새 댓글창을 만드는 것은 li에 ajax 요청으로 가져온 데이터를 담고,]
-       [ 새 댓글창(무한증식하는)의 [등록버튼] 의 id를 [동적으로 받는것]이 중요한데...] 이걸 어떻게 한담...

    ==>> 결론.
    -   [무한히 증식하는 버튼을 만들때, 각 버튼의 data-id] 안에, " DB에서 받아온, 각각의 댓글 id를 넣으면 된다"
        어떻게? 예를들어,

        어떤 사람이 댓글을 적어서, 그 댓글이 DB안에 들어갔다고 하자.
          DB에 들어간 댓글을 뽑아, li로 만들것이고, 그 댓글 자체의 id가 존재할것이다.
-       li안에 존재하는 버튼에, [댓글 자체의 id]를 [data-id] 안에 담아, 버튼을 만든다.

            <button  data-productId= '<%= product.id %>'   class=...   > </button>

        [그럼 그 버튼을 어떻게 타겟할 것인가?]

-       querySelectorAll 로, 전부 잡아서, for( cont x of Array) 로 전부 잡아 리스너를 달고
-       [function 에, event 파라미터로 [dataset을 가져와] [서버로 그 dataset을 보낸다] , dataset에는 data- 안에 담긴 DB의 productid가 존재하기 때문에,
-       타겟하여 서버로부터 요청을 주고받을 수 있다.
-       물론 [요청 하는 주소도 동적으로 보낼 수 있다.]

            const buttons = document.querySelectorAll(".상위클래스 button")

            async function function(event){
                const postId = event.target.dataset.postid      //만약, data-postid = "..." 

                await fetch(`/admin/products/` + postid, {
                    method="..."                                //get요청일경우, URL만으로 끝
                })
            }

            for( const button of buttons){
                button.addEventListenal("click", function)
            }


        [어떤 요청을 할것인가?]
-       fetch에는 모든 요청이 전부 가능하다 [get, post, delete, 등...] 선택해서 한다.

            <get (기본)>
                const response = fetch("URL")
                const responsData = response.json()

            <post>
                data = {...}

                fetch("URL", {
                    method : "post",
                    body : JSON.stringify(data),
                    headers : {
                        "Content-Type" : "application/json"
                    }
                })

            <delete>
                fetch("URL",{
                    method = "delete"
                })

            ...

-       추가적으로 요청인 만큼 CSRF토큰을 제시해야한다!
            그러므로, 보낼때 [data-보낼데이터 = "..."] 뿐 아니라,
                            [data-csrf = "<%= locals.csrfToken%>"] 도 같이 보내서,
        
            async function function(event){
                const postId = event.target.dataset.postid      //만약, data-postid = "..."  , data-csrf = "<%= locals.csrfToken%>" 
                const csrf = event.target.dataset.csrf

                const response = await fetch(`/admin/products/` + postid + `?_csrf` + csrf , {
                    method="..."                               
                })
            }

        처럼 csrfToken 도 제시해야, 값을 받고 보낼수 있다.

-       response가 ok가 아닐경우, error를 제시하는 것도 잊지 말아야한다.

            async function function(event){
                const postId = event.target.dataset.postid      //만약, data-postid = "..." 

                const reponse = await fetch("URL")

-              if(!response.ok){
                    alert("...")
                    return
                }
            }

2. DB에 넣었다고? [기다렸다가 다 들어간것을 확인하면!] [그제서야 다음 코드로 넘어가는 코드도 필요하지 않을까?]

    필요 : (함수내에 저장되엇음을 어떻게 알것인가?)
        : 만약 저장되는 중이라면, 어떻게 기다릴것인가?
        : WAIT 같은게 있나? STOP? 뭘까


3. 로그아웃 오른쪽에, user 아이디 넣고, 누르면 아래 팝업으로, [주문확인,개인정보] 나오게하기

4. PAY-TO-ORDER 옆에 사이드로, 그 사용자가 했던 [주문확인] 나오게하기
        